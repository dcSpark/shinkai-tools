{"type":"Deno","content":[{"toolkit_name":"email-answerer","name":"Email Answerer","author":"Shinkai","version":"1.0.0","js_code":"import {\n    emailFetcher,\n    sendEmail,\n    shinkaiLlmPromptProcessor,\n    shinkaiSqliteQueryExecutor,\n} from './shinkai-local-tools.ts';\n\ntype EMAIL = {\n    date: string;\n    sender: string;\n    subject: string;\n    text: string;\n}\n\ntype ANSWERED_EMAIL_REGISTER = {\n    email_unique_id: string;\n    subject: string;\n    email: string;\n    response: string;\n    received_date: string;\n    response_date: string;\n}\n\nasync function generateEmailUniqueId(email: EMAIL): Promise<string> {\n    const encoder = new TextEncoder();\n    if (!email.subject && !email.sender && !email.date) {\n        throw new Error('Email is empty subject, sender, and date, cannot generate unique id');\n    }\n    const data = encoder.encode((email.subject ?? '') + (email.sender ?? '') + (email.date ?? ''));\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\ntype CONFIG = {\n  response_context: string;\n};\n\ntype INPUTS = {\n  from_date?: string;\n  to_date?: string;\n};\n\ntype OUTPUT = {\n    table_created: boolean;\n    mail_ids: (string | number)[];\n    skipped: string[];\n    login_status: string;\n};\n\n// Helper function to escape user input\nfunction escapeSqlString(str: string): string {\n    return `'${str.replace(/'/g, \"''\").replace('--', '').replace(';', '')}'`; // Replaces single quotes with two single quotes\n}\n\nexport async function run(config: CONFIG, inputs: INPUTS): Promise<OUTPUT> {\n    const tableName = 'answered_emails';\n\n    const createTableQuery = `\n        CREATE TABLE IF NOT EXISTS ${tableName} (\n            email_unique_id TEXT UNIQUE PRIMARY KEY,\n            subject TEXT NOT NULL,\n            email TEXT NOT NULL,\n            response TEXT NOT NULL,\n            received_date DATETIME NOT NULL,\n            response_date DATETIME DEFAULT CURRENT_TIMESTAMP\n        );\n    `;\n\n    await shinkaiSqliteQueryExecutor({ query: createTableQuery });\n    // Ensure the connection is closed or cleaned up if necessary\n    // Verify table creation was successful\n    const tableCheck = await shinkaiSqliteQueryExecutor({\n        query: `SELECT name FROM sqlite_master WHERE type='table' AND name=?;`,\n        params: [tableName]\n    });\n    const tableCreated = (tableCheck?.result?.length ?? 0) > 0;\n    let { emails, login_status } = await emailFetcher({\n        from_date: inputs.from_date || '',\n        to_date: inputs.to_date || '',\n    });\n    inputs.from_date = undefined;\n    inputs.to_date = undefined;\n    const answeredEmailsQuery = await shinkaiSqliteQueryExecutor({\n        query: `SELECT * FROM ${tableName}`,\n    });\n    if (!answeredEmailsQuery?.result) {\n        throw new Error('Failed to query answered emails');\n    }\n    const answeredEmails: ANSWERED_EMAIL_REGISTER[] = (answeredEmailsQuery.result as ANSWERED_EMAIL_REGISTER[]) ?? [];\n    const mailIds: string[] = [];\n    const minDate = inputs.from_date ? new Date(inputs.from_date) : new Date('1970-01-01T00:00:00.000Z');\n    emails = emails\n        .filter((e: EMAIL) => (e.date && e.sender && e.subject))\n        .filter((e: EMAIL) => e.date > ((minDate && minDate.toISOString()) || '1970-01-01T00:00:00.000Z'))\n    \n    const insertMailIdQuery = (\n        emailUniqueId: string,\n        subject: string,\n        email: string,\n        response: string,\n        received_date: Date,\n    ) => `\n        INSERT INTO ${tableName} (email_unique_id, subject, email, response, received_date) \n        VALUES (${emailUniqueId}, ${subject}, ${email}, ${response}, ${Math.floor(received_date.getTime() / 1000)});\n    `;\n\n    const skipped: string[] = [];\n    try {\n        for (const email of emails as EMAIL[]) {\n            const emailUniqueId = await generateEmailUniqueId(email);\n            const answeredEmail = answeredEmails.find(answeredEmail => answeredEmail.email_unique_id === emailUniqueId);\n            if (answeredEmail) {\n                skipped.push(answeredEmail.email_unique_id)\n                console.log(`üê∏ Skipping email with subject ${answeredEmail.subject}`)\n                continue;\n            }\n\n            let response;\n            try {\n                response = await shinkaiLlmPromptProcessor({\n                    format: 'text',\n                    prompt: `You are a helpful email answering system.\n                    Please respond to a following email but only in the manner of the following context:\n                    <context>\n                      ${config.response_context}\n                    </context>\n                    This is the email you need to respond to:\n                    <email>\n                      <email.subject>${email.subject}</email.subject>\n                      <email.sender>${email.sender}</email.sender>\n                      <email.date>${email.date}</email.date>\n                      <email.text>${email.text}</email.text>\n                    </email>\n\n                    You'll be generating only the response to the email, no other text or markdown like html its neccesary.\n                    `,\n                });\n            } catch (error) {\n                console.error(`Failed to process email: ${error}`);\n                continue; // Skip this email if processing fails\n            }\n                \n            await sendEmail({\n                recipient_email: email.sender,\n                subject: 'RE:' + email.subject,\n                body: response.message\n            });\n            \n            const insertEmail = insertMailIdQuery(\n                escapeSqlString(emailUniqueId),\n                escapeSqlString(email.subject),\n                escapeSqlString(email.sender),\n                escapeSqlString(response.message),\n                new Date(email.date)\n            );\n            await shinkaiSqliteQueryExecutor({ query: insertEmail })\n            const mailId = emailUniqueId;\n            mailIds.push(mailId);\n        }\n    } catch (error) {\n        console.error(`Failed to process emails: ${error}`);\n        throw error; // Rethrow the error after rollback\n    }\n    return {\n        table_created: tableCreated,\n        mail_ids: mailIds,\n        login_status,\n        skipped,\n    };\n}\n","tools":["local:::rust_toolkit:::shinkai_sqlite_query_executor","local:::email_imap_fetcher:::email_fetcher","local:::email_sender_shinkai:::send_email","local:::rust_toolkit:::shinkai_llm_prompt_processor"],"config":[{"BasicConfig":{"key_name":"response_context","description":"The context to use when answering emails.","required":true,"type":null,"key_value":null}}],"description":"Tool for automatically answering emails by processing their content and responding to them.","keywords":["email","answer","processor","shinkai"],"input_args":{"type":"object","properties":{"from_date":{"type":"string","description":"The date from which to start processing emails (inclusive)."},"to_date":{"type":"string","description":"The date until which to process emails (exclusive)."}},"required":[]},"output_arg":{"json":""},"activated":false,"embedding":[-0.09985851,0.41992223,-0.12004921,-0.65672076,0.39591885,0.03171113,-0.07226634,0.13418892,0.37773234,0.095823616,-0.27842966,0.5737561,-0.14799337,-0.32679847,0.26278412,-0.27252376,0.023710428,-0.73856074,-1.7764609,-0.024215154,-0.071724065,0.51910317,0.41663653,0.27744022,-0.18640056,-0.1412967,-0.26539823,-0.29159713,-1.0645298,-1.5616181,0.7318345,0.4630917,-0.09768544,0.18475255,-0.31483483,-0.8806548,0.045418985,0.7320302,-0.5062949,-0.5591957,0.6621704,0.47486767,-0.5485827,-0.38923874,0.027039038,-0.3208995,0.18409902,-0.19852482,0.62323356,1.1423376,-0.29865226,-0.32728508,0.06757504,0.011682838,-0.30320862,0.22403404,-0.08006736,-0.23536871,-0.25722864,-0.14303279,0.07184484,0.059820488,-4.103936,0.026317094,0.32570758,-0.19826949,0.24358116,-0.203736,0.20447327,-0.14635731,0.17733417,0.22320257,-0.92686474,0.66302633,0.47925895,-0.5205876,-0.2055311,-0.32124284,0.69573456,-0.53343475,0.36255255,0.75530005,-0.019595308,0.053144563,-0.9027147,0.16557506,-0.31666303,-0.59595895,0.087919936,0.1706427,-0.3849518,-0.6034928,-0.008018697,-0.15535697,-0.14670011,0.16725639,-0.33451593,0.31433433,0.2513728,3.0496314,0.5148341,-0.14858198,0.33689693,-1.1889803,0.30593,-0.45296368,-0.44431898,-0.89669794,0.018077554,0.05960524,-0.14916553,-0.00020011887,-0.23338673,0.25307718,-0.14570162,-0.064205796,-0.20404162,0.6621008,-0.40003547,0.92348033,0.0039137304,0.48920617,-0.3967268,-0.14902142,-0.25922528,0.45340368,-0.06646332,0.34597403,0.246404,0.35795265,0.8073371,-0.73999,-1.3352734,-0.416408,-0.35875425,0.22857976,0.87159437,-0.27707416,0.46655366,-0.45533603,0.18971612,-1.3398782,0.95085275,0.45074913,0.7840571,0.38695052,-0.041590944,0.17936872,-0.37343398,-0.021297518,-0.10988118,0.7074091,-0.31377855,-0.20488518,0.5531475,0.35868225,-0.20583926,-0.5925287,-0.33645293,-0.010709219,-0.21971744,-0.02493093,0.32378396,0.56636673,0.27111152,-0.6108487,-0.009705529,-0.24498448,0.034020167,-0.31361794,0.3016987,0.121328324,-0.14855805,0.3490593,-0.71588063,-0.26339504,0.10573955,0.25633395,0.3710813,-0.9818953,0.8665151,0.80591035,-0.34483325,-0.428555,0.14673492,0.56727344,-0.051773667,0.00081272796,1.03209,0.83792174,-0.7451982,1.5228243,-0.40058577,-0.6200303,0.16965763,0.20172136,-0.27264586,0.35060263,0.77300495,-0.08666761,-0.6251472,-0.4829298,-0.10457234,0.58370256,-0.31508803,-0.27231908,-0.109491244,0.23013608,0.31288865,-0.768549,0.010679377,-0.36449796,0.31897122,0.5963579,0.63829565,0.14162746,-0.012096845,-0.0585918,-0.033005834,0.6231268,0.7877326,-0.08274295,-0.5439343,-0.5455469,-0.5212696,0.6198795,-0.5812921,0.15766957,-0.078437164,-0.20421016,0.44780773,1.0819429,0.42778358,0.99357295,0.53544074,0.36107627,-0.45699495,0.8482958,0.6293901,-0.29527885,0.35279608,-0.481279,-0.36175683,0.410199,0.0707047,-0.40803975,0.51825434,-0.1351583,0.19316107,1.143534,0.21820083,0.5560332,0.19531396,0.39858308,-0.2606566,-0.14008945,-1.1986159,0.4774295,-0.70564175,0.85032564,0.111924194,-0.33325583,0.92645276,0.55054927,-0.08150864,-0.12028319,-0.64827335,-0.83630574,-0.33341813,0.086112894,-0.35005444,0.36340836,-0.27054167,-0.08749605,-0.28763008,-0.07928019,0.4501998,0.44531772,-0.35976437,-0.807098,-0.01792501,-0.025507998,0.24706668,-0.09043433,-0.81316817,-0.113369234,-0.26769114,-0.47778618,-0.5550028,0.94598913,-0.12513545,-0.739502,-0.43858352,0.41866902,2.119558,0.8783374,0.1405863,0.5250694,0.26140442,0.435696,0.025377937,0.36144233,-0.4267802,-0.66928786,-0.7562486,-0.5695229,0.48990077,-0.14522375,-0.41317055,-0.21128955,-0.54286426,0.19401544,-0.14524706,0.42075133,0.7353583,-0.28700352,1.0308704,0.027792431,-0.08629088,-2.3009906,0.013498096,0.4897199,0.1434111,-0.098885186,-0.27055186,0.14219065,-0.10567584,-0.06458485,-0.52829903,0.78343916,0.31948823,-0.4972912,0.182031,-0.068416424,0.6322392,0.28617698,0.015289301,-0.5621281,-1.0010431,-0.20688461,0.47176483,2.0685585,0.09178205,-0.02966639,0.060745124,0.3316962,-0.3634292,-1.6005789,0.0755179,0.06307718,-0.33131552,1.0656507,-0.044327427,-0.56029916,0.24818929,0.8565493,-0.37231588,-0.22803673,-0.7573291,1.5341315,-0.12744786,-0.07526349,-0.82769096,0.2538394,-0.26462355,0.17901422,1.0399874,-0.35634437,-0.19371632,0.40741196,0.1992828,-0.14409436,0.54181623,0.023502825,0.27126762,0.23331052,-0.10381478,0.67352355,0.4075753,0.6132025,0.13684294,0.3471062,-0.34013706,0.4969532],"result":{"type":"object","properties":{"login_status":{"description":"The status of the login process on the imap fetcher.","type":"string"},"mail_ids":{"description":"The IDs of the emails that were processed and answered.","items":{"type":"string"},"type":"array"},"skipped":{"description":"The IDs of the emails that were skipped.","items":{"type":"string"},"type":"array"},"table_created":{"description":"Whether the table was created successfully.","type":"boolean"}},"required":["table_created","mail_ids","login_status","skipped"]},"sql_tables":[{"name":"answered_emails","definition":"CREATE TABLE IF NOT EXISTS answered_emails (email_unique_id TEXT UNIQUE PRIMARY KEY, subject TEXT NOT NULL, email TEXT NOT NULL, response TEXT NOT NULL, received_date DATETIME NOT NULL, response_date DATETIME DEFAULT CURRENT_TIMESTAMP)"}],"sql_queries":[{"name":"Get emails","query":"SELECT * FROM answered_emails"},{"name":"Get email by unique ID","query":"SELECT * FROM answered_emails WHERE email_unique_id = :emailUniqueId"}],"file_inbox":null,"oauth":null,"assets":null},false]}