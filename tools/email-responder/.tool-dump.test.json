{"type":"Deno","content":[{"name":"Email Answerer","tool_router_key":"local:::__official_shinkai:::email_answerer","homepage":null,"author":"@@official.shinkai","version":"1.0.0","mcp_enabled":null,"js_code":"import {\n    emailFetcher,\n    sendEmail,\n    shinkaiLlmPromptProcessor,\n    shinkaiSqliteQueryExecutor,\n    memoryManagement,\n} from './shinkai-local-tools.ts';\n\ntype EMAIL = {\n    date: string;\n    sender: string;\n    subject: string;\n    text: string;\n}\n\ntype ANSWERED_EMAIL_REGISTER = {\n    email_unique_id: string;\n    subject: string;\n    email: string;\n    response: string;\n    received_date: string;\n    response_date: string;\n}\n\nasync function generateEmailUniqueId(email: EMAIL): Promise<string> {\n    const encoder = new TextEncoder();\n    if (!email.subject && !email.sender && !email.date) {\n        throw new Error('Email is empty subject, sender, and date, cannot generate unique id');\n    }\n    const data = encoder.encode((email.subject ?? '') + (email.sender ?? '') + (email.date ?? ''));\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\ntype CONFIG = {\n  response_context: string;\n};\n\ntype INPUTS = {\n  from_date?: string;\n  to_date?: string;\n};\n\ntype OUTPUT = {\n    table_created: boolean;\n    mail_ids: (string | number)[];\n    skipped: string[];\n    login_status: string;\n};\n\n// Helper function to escape user input\nfunction escapeSqlString(str: string): string {\n    return `'${str.replace(/'/g, \"''\").replace('--', '').replace(';', '')}'`; // Replaces single quotes with two single quotes\n}\n\n// Validate inputs\nfunction validateInputs(inputs: INPUTS): void {\n    if (!inputs.from_date && !inputs.to_date) return\n    // Check if dates are on the DD-Mon-YYYY format\n    const dateRegex = /^[0-3]{1}[0-9]{1}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-\\d{4}$/;\n    if (inputs.from_date) {\n        if (!dateRegex.test(inputs.from_date)) {\n            throw new Error('from_date : Invalid from_date format. It must be on the DD-Mon-YYYY format');\n        }\n    }\n    if (inputs.to_date) {\n        if (!dateRegex.test(inputs.to_date)) {\n            throw new Error('to_date : Invalid to_date format. It must be on the DD-Mon-YYYY format');\n        }\n    }\n    return\n}\n\nfunction getTodayInDDMonYYYY(): string {\n    const date = new Date();\n    const day = date.getDate().toString().padStart(2, '0');\n    const month = date.toLocaleString('en-US', { month: 'short' });\n    const year = date.getFullYear();\n    return `${day}-${month}-${year}`;\n}\n\nexport async function run(config: CONFIG, inputs: INPUTS): Promise<OUTPUT> {\n    if (inputs.from_date || inputs.to_date) {\n        validateInputs(inputs)\n    }\n    const tableName = 'answered_emails';\n\n    const createTableQuery = `\n        CREATE TABLE IF NOT EXISTS ${tableName} (\n            email_unique_id TEXT UNIQUE PRIMARY KEY,\n            subject TEXT NOT NULL,\n            email TEXT NOT NULL,\n            response TEXT NOT NULL,\n            received_date DATETIME NOT NULL,\n            response_date DATETIME DEFAULT CURRENT_TIMESTAMP\n        );\n    `;\n\n    await shinkaiSqliteQueryExecutor({ query: createTableQuery });\n    // Ensure the connection is closed or cleaned up if necessary\n    // Verify table creation was successful\n    const tableCheck = await shinkaiSqliteQueryExecutor({\n        query: `SELECT name FROM sqlite_master WHERE type='table' AND name=?;`,\n        params: [tableName]\n    });\n    const tableCreated = (tableCheck?.result?.length ?? 0) > 0;\n    let { emails, login_status } = await emailFetcher({\n        from_date: inputs.from_date || getTodayInDDMonYYYY(),\n        to_date: inputs.to_date || '01-Jan-2099',\n    });\n\n    const answeredEmailsQuery = await shinkaiSqliteQueryExecutor({\n        query: `SELECT * FROM ${tableName}`,\n    });\n    if (!answeredEmailsQuery?.result) {\n        throw new Error('Failed to query answered emails');\n    }\n    const answeredEmails: ANSWERED_EMAIL_REGISTER[] = (answeredEmailsQuery.result as ANSWERED_EMAIL_REGISTER[]) ?? [];\n    const mailIds: string[] = [];\n    const minDate = inputs.from_date ? new Date(inputs.from_date) : new Date('1970-01-01T00:00:00.000Z');\n    emails = emails\n        .filter((e: EMAIL) => (e.date && e.sender && e.subject))\n        .filter((e: EMAIL) => e.date > ((minDate && minDate.toISOString()) || '1970-01-01T00:00:00.000Z'))\n    \n    const insertMailIdQuery = (\n        emailUniqueId: string,\n        subject: string,\n        email: string,\n        response: string,\n        received_date: Date,\n    ) => `\n        INSERT INTO ${tableName} (email_unique_id, subject, email, response, received_date) \n        VALUES (${emailUniqueId}, ${subject}, ${email}, ${response}, ${Math.floor(received_date.getTime() / 1000)});\n    `;\n\n    const skipped: string[] = [];\n    try {\n        for (const email of emails as EMAIL[]) {\n            const emailUniqueId = await generateEmailUniqueId(email);\n            const { specificMemory } = await memoryManagement({ key: email.sender, data: '#' })\n            const answeredEmail = answeredEmails.find(answeredEmail => answeredEmail.email_unique_id === emailUniqueId);\n            if (answeredEmail) {\n                skipped.push(answeredEmail.email_unique_id)\n                console.log(`üê∏ Skipping email with subject ${answeredEmail.subject}`)\n                continue;\n            }\n\n            let response;\n            try {\n                response = await shinkaiLlmPromptProcessor({\n                    format: 'text',\n                    prompt: `You are a helpful email answering system.\n                    Please respond to a following email but only in the manner of the following context:\n                    <context>\n                      ${config.response_context}\n                      # memories of past conversations with this email sender:\n                      <memories>\n                      ${specificMemory || 'No memories found'}\n                      </memories>\n                    </context>\n                    This is the email you need to respond to:\n                    <email>\n                      <email.subject>${email.subject}</email.subject>\n                      <email.sender>${email.sender}</email.sender>\n                      <email.date>${email.date}</email.date>\n                      <email.text>${email.text}</email.text>\n                    </email>\n\n                    You'll be generating only the response to the email, no other text or markdown like html its neccesary.\n                    `,\n                });\n            } catch (error) {\n                console.error(`Failed to process email: ${error}`);\n                continue; // Skip this email if processing fails\n            }\n                \n            await sendEmail({\n                recipient_email: email.sender,\n                subject: 'RE:' + email.subject,\n                body: response.message\n            });\n            const _insertMemory = await memoryManagement({ key: email.sender, data: `\n                <received_email>\n                  <email.subject>${email.subject}</email.subject>\n                  <email.sender>${email.sender}</email.sender>\n                  <email.date>${email.date}</email.date>\n                  <email.text>${email.text}</email.text>\n                </received_email>\n                <answered_email>\n                  <response>${response.message}</response>\n                </answered_email>\n                ` \n            })\n            const insertEmail = insertMailIdQuery(\n                escapeSqlString(emailUniqueId),\n                escapeSqlString(email.subject),\n                escapeSqlString(email.sender),\n                escapeSqlString(response.message),\n                new Date(email.date)\n            );\n            await shinkaiSqliteQueryExecutor({ query: insertEmail })\n            const mailId = emailUniqueId;\n            mailIds.push(mailId);\n        }\n    } catch (error) {\n        console.error(`Failed to process emails: ${error}`);\n        throw error; // Rethrow the error after rollback\n    }\n    return {\n        table_created: tableCreated,\n        mail_ids: mailIds,\n        login_status,\n        skipped,\n    };\n}\n","tools":["local:::__official_shinkai:::email_fetcher","local:::__official_shinkai:::send_email","local:::__official_shinkai:::shinkai_sqlite_query_executor","local:::__official_shinkai:::shinkai_llm_prompt_processor","local:::__official_shinkai:::memory_insights_management"],"config":[{"BasicConfig":{"key_name":"response_context","description":"The context to guide the email responses","required":true,"type":null,"key_value":null}}],"description":"Generates responses to emails based on a given context and memory, and logs answered emails in a database.","keywords":["email","responder","database","shinkai"],"input_args":{"type":"object","properties":{"to_date":{"type":"string","description":"The ending date for fetching emails in DD-Mon-YYYY format"},"from_date":{"type":"string","description":"The starting date for fetching emails in DD-Mon-YYYY format"}},"required":[]},"output_arg":{"json":""},"activated":false,"embedding":[-0.30170557,0.67720854,-0.43203637,-0.3664619,0.17706461,-0.029133357,-0.5257523,0.49934655,0.16200729,0.26559043,-0.37419534,0.21141516,0.050515745,-0.31277114,0.76360005,0.046428688,0.0706362,-0.2928273,-1.9154634,0.099736445,-0.1643488,0.7858793,0.686102,0.117093384,-0.13358356,-0.21148169,0.23116428,-0.31846416,-1.2248652,-1.326515,0.59558266,0.72148883,-0.51081103,0.05929646,-0.47273874,-0.23423147,-0.119954586,0.4760154,-0.5910631,-0.06254007,0.58689785,0.3632428,-0.38003844,-0.25620162,0.018289845,-0.22198772,-0.06388869,-0.076718576,0.777459,0.858376,-0.14762074,-0.427974,0.23704006,0.12860835,-0.114003494,0.33892477,0.0150928125,-0.2936036,-0.01644576,-0.39401755,0.059193168,-0.018624023,-3.9494693,0.19525337,0.037539095,-0.25703418,0.3135877,0.42187443,0.48011437,-0.2713431,-0.22463241,0.3207418,-0.7369222,1.238955,0.38833085,-0.20094231,-0.012541797,-0.11342619,0.7460425,-0.5133329,0.4411946,0.7554747,-0.35185084,-0.10965976,-0.39310887,0.68061143,-0.07202718,-0.22313893,0.30540836,0.030527245,-0.28484967,-0.82861537,0.53674126,-0.17291367,-0.17937237,-0.18383645,-0.30565178,-0.011060014,-0.3042969,2.9646928,0.135212,-0.7117578,0.001939401,-1.0048729,0.42279297,-0.5164851,0.20675948,-0.91912526,-0.022920195,0.19097489,-0.010649033,-0.04399516,-0.2143332,0.6461722,0.06443804,0.08474438,-0.25249058,0.43214008,-0.20648609,0.7209297,0.0039522797,0.07917118,-0.51162887,-0.22452456,-0.19548038,0.23225407,0.392769,0.45160708,0.18360092,0.035098687,0.9149228,-0.59778523,-0.97725844,-0.062408924,-0.05500397,-0.084301166,0.553459,-0.35555997,-0.07648454,-0.32067505,-0.10555774,-2.014371,0.96697515,0.39920807,0.4971628,0.03950057,-0.6601911,0.032415867,-0.3338072,-0.22427928,0.06551427,0.2182074,-0.13541844,-0.11879631,0.2436305,-0.16676268,-0.028956987,-0.27704537,-0.45037475,-0.14626768,-0.047049552,-0.23427646,0.39918536,0.30931723,0.35331863,-0.623232,-0.2938023,0.068766385,0.11936672,-0.56685114,0.3565477,0.21989965,-0.39684823,0.24922176,-0.34821,-0.45977885,0.4957401,0.0013935864,0.057292897,-0.57103497,0.8229793,1.0181769,-0.3111484,-0.36622664,0.21305759,0.22965112,0.15415233,-0.06495579,0.9380403,0.58591235,-0.7204176,1.2318813,-0.43628138,-0.37530798,-0.031579807,-0.12693143,-0.31822807,0.81658137,0.991343,-0.23783472,-0.6709467,-0.40761706,-0.575888,0.75878215,0.36684865,0.2153517,-0.53573924,-0.037081,0.17638704,-0.9289596,-0.28160885,-0.18456334,0.41403016,0.6612648,0.63407373,0.42358065,0.23231749,-0.19664484,0.08942764,0.64946276,0.73696345,-0.41982898,-0.17949377,-0.59678406,-0.4645048,0.6219122,-0.5432716,0.092006475,-0.03574788,-0.26054958,0.6429122,1.5916941,0.009814404,1.2529892,0.74792945,0.3353826,-0.37434453,0.44633722,0.11105302,-0.5712839,0.35873434,-0.6549947,-0.22768995,0.23947097,0.0791859,-0.101623304,0.33143365,-0.31114718,0.2226663,1.5534225,0.82674193,0.7231174,-0.16760348,0.10723148,-0.18911877,0.10240121,-1.6524738,0.055883247,-0.61135244,0.5091111,0.20806137,-0.53519756,0.7387596,0.35093588,-0.041564643,-0.41971496,-0.951801,-0.99859285,-0.37624767,-0.06541923,-0.66637045,0.34704497,-0.62469304,-0.19443989,-0.08591629,-0.25071234,0.6597318,0.38311365,-0.09603001,-0.3348085,0.25074208,-0.14085954,0.41023916,-0.032484084,-0.39608818,-0.31219375,-0.19337231,-0.75854367,-0.23580807,0.7571846,-0.013864204,-0.7904932,-0.47416073,0.3815412,1.7257192,1.0237951,0.025943644,0.9231136,0.64821637,0.5860464,0.22195566,0.52055424,-0.42265925,-0.31860563,-0.5873206,-0.66191334,0.25148606,-0.0329971,-0.27614856,0.15052584,-0.698441,-0.11828941,0.16466495,0.27277845,0.7078901,-0.45066774,1.2363999,0.6608604,0.15360585,-2.0083597,0.2513371,0.59024996,0.27923635,0.17843947,-0.2195443,0.52860945,-0.6507472,0.10782598,-0.47445214,0.555071,0.196921,-0.64243984,0.09342988,-0.41566423,0.5664425,0.4289199,-0.34977183,-0.80383307,-0.5964875,-0.27459508,0.5660259,1.8320544,0.42195678,-0.13899028,0.21569768,0.28275356,-0.58617616,-1.621573,0.13236181,-0.37945867,-0.38373876,1.0772992,0.25539264,-0.40276802,-0.46333656,0.71168596,-0.53453344,-0.23951405,-0.60148895,1.4481384,-0.20676869,-0.35670745,-1.1282582,0.26373076,-0.6876034,-0.03504145,0.8356934,0.13997465,-0.319793,0.37837553,0.35233366,0.29508406,0.46235192,0.34897897,0.25089368,-0.180618,-0.1548198,0.279982,0.084827185,0.3673836,0.43544018,0.69406265,-0.326281,0.39533758],"result":{"type":"object","properties":{"login_status":{"description":"The status of the email login","type":"string"},"mail_ids":{"description":"The list of generated unique mail IDs","items":{"type":"string"},"type":"array"},"skipped":{"description":"List of email IDs that were skipped","items":{"type":"string"},"type":"array"},"table_created":{"description":"Indicates if the email logging table was created","type":"boolean"}},"required":["table_created","mail_ids"]},"sql_tables":[{"name":"answered_emails","definition":"CREATE TABLE IF NOT EXISTS answered_emails (email_unique_id TEXT UNIQUE PRIMARY KEY, subject TEXT NOT NULL, email TEXT NOT NULL, response TEXT NOT NULL, received_date DATETIME NOT NULL, response_date DATETIME DEFAULT CURRENT_TIMESTAMP)"}],"sql_queries":[{"name":"Get answered emails","query":"SELECT * FROM answered_emails"},{"name":"Get email by unique ID","query":"SELECT * FROM answered_emails WHERE email_unique_id = :emailUniqueId"},{"name":"Insert new email","query":"INSERT INTO answered_emails (email_unique_id, subject, email, response, received_date) VALUES (:emailUniqueId, :subject, :email, :response, :receivedDate)"}],"file_inbox":null,"oauth":null,"assets":null,"runner":"any","operating_system":["linux","macos","windows"],"tool_set":""},false]}