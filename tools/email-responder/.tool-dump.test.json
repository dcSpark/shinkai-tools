{"type":"Deno","content":[{"name":"Email Answerer","homepage":null,"author":"@@official.shinkai","version":"1.0.0","js_code":"import {\n    emailFetcher,\n    sendEmail,\n    shinkaiLlmPromptProcessor,\n    shinkaiSqliteQueryExecutor,\n    memoryManagement,\n} from './shinkai-local-tools.ts';\n\ntype EMAIL = {\n    date: string;\n    sender: string;\n    subject: string;\n    text: string;\n}\n\ntype ANSWERED_EMAIL_REGISTER = {\n    email_unique_id: string;\n    subject: string;\n    email: string;\n    response: string;\n    received_date: string;\n    response_date: string;\n}\n\nasync function generateEmailUniqueId(email: EMAIL): Promise<string> {\n    const encoder = new TextEncoder();\n    if (!email.subject && !email.sender && !email.date) {\n        throw new Error('Email is empty subject, sender, and date, cannot generate unique id');\n    }\n    const data = encoder.encode((email.subject ?? '') + (email.sender ?? '') + (email.date ?? ''));\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\ntype CONFIG = {\n  response_context: string;\n};\n\ntype INPUTS = {\n  from_date?: string;\n  to_date?: string;\n};\n\ntype OUTPUT = {\n    table_created: boolean;\n    mail_ids: (string | number)[];\n    skipped: string[];\n    login_status: string;\n};\n\n// Helper function to escape user input\nfunction escapeSqlString(str: string): string {\n    return `'${str.replace(/'/g, \"''\").replace('--', '').replace(';', '')}'`; // Replaces single quotes with two single quotes\n}\n\n// Validate inputs\nfunction validateInputs(inputs: INPUTS): void {\n    if (!inputs.from_date && !inputs.to_date) return\n    // Check if dates are on the DD-Mon-YYYY format\n    const dateRegex = /^[0-3]{1}[0-9]{1}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-\\d{4}$/;\n    if (inputs.from_date) {\n        if (!dateRegex.test(inputs.from_date)) {\n            throw new Error('from_date : Invalid from_date format. It must be on the DD-Mon-YYYY format');\n        }\n    }\n    if (inputs.to_date) {\n        if (!dateRegex.test(inputs.to_date)) {\n            throw new Error('to_date : Invalid to_date format. It must be on the DD-Mon-YYYY format');\n        }\n    }\n    return\n}\n\nfunction getTodayInDDMonYYYY(): string {\n    const date = new Date();\n    const day = date.getDate().toString().padStart(2, '0');\n    const month = date.toLocaleString('en-US', { month: 'short' });\n    const year = date.getFullYear();\n    return `${day}-${month}-${year}`;\n}\n\nexport async function run(config: CONFIG, inputs: INPUTS): Promise<OUTPUT> {\n    if (inputs.from_date || inputs.to_date) {\n        validateInputs(inputs)\n    }\n    const tableName = 'answered_emails';\n\n    const createTableQuery = `\n        CREATE TABLE IF NOT EXISTS ${tableName} (\n            email_unique_id TEXT UNIQUE PRIMARY KEY,\n            subject TEXT NOT NULL,\n            email TEXT NOT NULL,\n            response TEXT NOT NULL,\n            received_date DATETIME NOT NULL,\n            response_date DATETIME DEFAULT CURRENT_TIMESTAMP\n        );\n    `;\n\n    await shinkaiSqliteQueryExecutor({ query: createTableQuery });\n    // Ensure the connection is closed or cleaned up if necessary\n    // Verify table creation was successful\n    const tableCheck = await shinkaiSqliteQueryExecutor({\n        query: `SELECT name FROM sqlite_master WHERE type='table' AND name=?;`,\n        params: [tableName]\n    });\n    const tableCreated = (tableCheck?.result?.length ?? 0) > 0;\n    let { emails, login_status } = await emailFetcher({\n        from_date: inputs.from_date || getTodayInDDMonYYYY(),\n        to_date: inputs.to_date || '01-Jan-2099',\n    });\n\n    const answeredEmailsQuery = await shinkaiSqliteQueryExecutor({\n        query: `SELECT * FROM ${tableName}`,\n    });\n    if (!answeredEmailsQuery?.result) {\n        throw new Error('Failed to query answered emails');\n    }\n    const answeredEmails: ANSWERED_EMAIL_REGISTER[] = (answeredEmailsQuery.result as ANSWERED_EMAIL_REGISTER[]) ?? [];\n    const mailIds: string[] = [];\n    const minDate = inputs.from_date ? new Date(inputs.from_date) : new Date('1970-01-01T00:00:00.000Z');\n    emails = emails\n        .filter((e: EMAIL) => (e.date && e.sender && e.subject))\n        .filter((e: EMAIL) => e.date > ((minDate && minDate.toISOString()) || '1970-01-01T00:00:00.000Z'))\n    \n    const insertMailIdQuery = (\n        emailUniqueId: string,\n        subject: string,\n        email: string,\n        response: string,\n        received_date: Date,\n    ) => `\n        INSERT INTO ${tableName} (email_unique_id, subject, email, response, received_date) \n        VALUES (${emailUniqueId}, ${subject}, ${email}, ${response}, ${Math.floor(received_date.getTime() / 1000)});\n    `;\n\n    const skipped: string[] = [];\n    try {\n        for (const email of emails as EMAIL[]) {\n            const emailUniqueId = await generateEmailUniqueId(email);\n            const { specificMemory } = await memoryManagement({ key: email.sender, data: '#' })\n            const answeredEmail = answeredEmails.find(answeredEmail => answeredEmail.email_unique_id === emailUniqueId);\n            if (answeredEmail) {\n                skipped.push(answeredEmail.email_unique_id)\n                console.log(`üê∏ Skipping email with subject ${answeredEmail.subject}`)\n                continue;\n            }\n\n            let response;\n            try {\n                response = await shinkaiLlmPromptProcessor({\n                    format: 'text',\n                    prompt: `You are a helpful email answering system.\n                    Please respond to a following email but only in the manner of the following context:\n                    <context>\n                      ${config.response_context}\n                      # memories of past conversations with this email sender:\n                      <memories>\n                      ${specificMemory || 'No memories found'}\n                      </memories>\n                    </context>\n                    This is the email you need to respond to:\n                    <email>\n                      <email.subject>${email.subject}</email.subject>\n                      <email.sender>${email.sender}</email.sender>\n                      <email.date>${email.date}</email.date>\n                      <email.text>${email.text}</email.text>\n                    </email>\n\n                    You'll be generating only the response to the email, no other text or markdown like html its neccesary.\n                    `,\n                });\n            } catch (error) {\n                console.error(`Failed to process email: ${error}`);\n                continue; // Skip this email if processing fails\n            }\n                \n            await sendEmail({\n                recipient_email: email.sender,\n                subject: 'RE:' + email.subject,\n                body: response.message\n            });\n            const _insertMemory = await memoryManagement({ key: email.sender, data: `\n                <received_email>\n                  <email.subject>${email.subject}</email.subject>\n                  <email.sender>${email.sender}</email.sender>\n                  <email.date>${email.date}</email.date>\n                  <email.text>${email.text}</email.text>\n                </received_email>\n                <answered_email>\n                  <response>${response.message}</response>\n                </answered_email>\n                ` \n            })\n            const insertEmail = insertMailIdQuery(\n                escapeSqlString(emailUniqueId),\n                escapeSqlString(email.subject),\n                escapeSqlString(email.sender),\n                escapeSqlString(response.message),\n                new Date(email.date)\n            );\n            await shinkaiSqliteQueryExecutor({ query: insertEmail })\n            const mailId = emailUniqueId;\n            mailIds.push(mailId);\n        }\n    } catch (error) {\n        console.error(`Failed to process emails: ${error}`);\n        throw error; // Rethrow the error after rollback\n    }\n    return {\n        table_created: tableCreated,\n        mail_ids: mailIds,\n        login_status,\n        skipped,\n    };\n}\n","tools":["local:::__official_shinkai:::email_fetcher","local:::__official_shinkai:::send_email","local:::__official_shinkai:::shinkai_sqlite_query_executor","local:::__official_shinkai:::shinkai_llm_prompt_processor","local:::__official_shinkai:::memory_management"],"config":[{"BasicConfig":{"key_name":"response_context","description":"The context to guide the email responses","required":true,"type":null,"key_value":null}}],"description":"Generates responses to emails based on a given context and memory, and logs answered emails in a database.","keywords":["email","responder","database","shinkai"],"input_args":{"type":"object","properties":{"to_date":{"type":"string","description":"The ending date for fetching emails in DD-Mon-YYYY format"},"from_date":{"type":"string","description":"The starting date for fetching emails in DD-Mon-YYYY format"}},"required":[]},"output_arg":{"json":""},"activated":false,"embedding":[-0.30160928,0.67717886,-0.4322511,-0.36650854,0.17701775,-0.029251136,-0.5258444,0.49951208,0.16187188,0.26544487,-0.37414777,0.21136293,0.05033677,-0.3126728,0.7634731,0.046571933,0.07062693,-0.29268694,-1.9152012,0.09953306,-0.16451852,0.7857904,0.686115,0.11705001,-0.13328183,-0.21128266,0.23142299,-0.3185498,-1.2249476,-1.3266835,0.59554166,0.7213682,-0.5107288,0.059182838,-0.47254252,-0.23404837,-0.120174676,0.47546884,-0.5912289,-0.062716514,0.58690315,0.36321115,-0.38013643,-0.25597966,0.018361852,-0.22162679,-0.06384943,-0.07689182,0.7772658,0.8583219,-0.14775123,-0.42806613,0.23700212,0.12848254,-0.1140695,0.3388893,0.015029535,-0.29331636,-0.016507443,-0.39420602,0.05923882,-0.018383235,-3.9494703,0.19543925,0.03739322,-0.25684634,0.31338164,0.42199448,0.48000866,-0.271337,-0.22447014,0.32070038,-0.7371344,1.2387346,0.38834032,-0.20106517,-0.012331404,-0.11354436,0.7460065,-0.5133005,0.44120795,0.75562674,-0.35178638,-0.10958873,-0.3931743,0.6807675,-0.07204697,-0.22315043,0.30575168,0.030470103,-0.28454387,-0.8287612,0.5367448,-0.17306441,-0.17944345,-0.18390672,-0.3057208,-0.010982722,-0.30409643,2.964792,0.13529381,-0.711479,0.0022296011,-1.005091,0.42289382,-0.5163104,0.20672205,-0.919324,-0.022783445,0.1908918,-0.010506898,-0.04404326,-0.21439502,0.6459613,0.06411126,0.08493342,-0.25258496,0.43225545,-0.20665924,0.7208773,0.0041208863,0.07908209,-0.51187176,-0.22449929,-0.195619,0.23227623,0.39279953,0.45170504,0.18363768,0.035344087,0.91490334,-0.59799963,-0.9771259,-0.06274269,-0.054869466,-0.08414035,0.5538423,-0.35538474,-0.076440714,-0.3206965,-0.10552406,-2.014307,0.96668446,0.39891177,0.4973475,0.03936296,-0.6603491,0.032400712,-0.3337222,-0.2241773,0.06556061,0.21809816,-0.13534349,-0.11886731,0.24354486,-0.16657957,-0.02861024,-0.27697042,-0.4505665,-0.14624187,-0.04704337,-0.23399259,0.3990878,0.30915716,0.35330132,-0.6231617,-0.29372683,0.06911435,0.11931896,-0.56670743,0.35693133,0.21961069,-0.3967881,0.24935545,-0.34806406,-0.45969424,0.49558315,0.0017653927,0.057242304,-0.5709171,0.82297546,1.0182934,-0.3112916,-0.36621296,0.21310155,0.2296645,0.1541861,-0.06473474,0.9381486,0.58597934,-0.7204826,1.2318189,-0.4364589,-0.37543827,-0.031741075,-0.12700588,-0.3180621,0.81643766,0.9912723,-0.23776829,-0.67091745,-0.40767476,-0.5760476,0.75886226,0.36673674,0.21543583,-0.5355634,-0.037257172,0.17624314,-0.92904425,-0.28127345,-0.1845923,0.41406468,0.6612436,0.63401735,0.4237126,0.23235948,-0.19659789,0.089210615,0.6496098,0.7370103,-0.41975042,-0.17939922,-0.5968706,-0.46433568,0.6218224,-0.5432305,0.09181826,-0.035572205,-0.26056433,0.6427494,1.5917606,0.009843186,1.252941,0.7476638,0.3353797,-0.3741541,0.4464214,0.110837325,-0.5709675,0.35869256,-0.6551249,-0.22774357,0.23962264,0.07920181,-0.10172166,0.3314637,-0.31137112,0.22255822,1.5535393,0.8264385,0.72304636,-0.167512,0.107184276,-0.18893349,0.10255157,-1.6523613,0.055841148,-0.61139375,0.5092495,0.20821503,-0.5351073,0.7388683,0.3510846,-0.041543454,-0.41995573,-0.9519685,-0.9988415,-0.37637216,-0.065479964,-0.66645473,0.34684986,-0.62474084,-0.1945132,-0.08595033,-0.25059602,0.6598771,0.38306752,-0.096167535,-0.33462778,0.25090736,-0.14077263,0.41022074,-0.032457843,-0.39594895,-0.31209314,-0.19358307,-0.75830185,-0.23580626,0.7569412,-0.013618309,-0.79057705,-0.474253,0.38156217,1.7257736,1.0237458,0.025998197,0.922849,0.6480505,0.58603096,0.2220225,0.520572,-0.4226414,-0.31868437,-0.5875114,-0.66161126,0.25158823,-0.033079542,-0.27615055,0.15040594,-0.6983925,-0.11842218,0.16466223,0.27259275,0.70768875,-0.45043695,1.2367421,0.66091526,0.15363751,-2.0084012,0.25103742,0.5903221,0.27917907,0.17843619,-0.21988584,0.5285674,-0.65083665,0.10759954,-0.4745211,0.5549319,0.19675212,-0.6425664,0.09324993,-0.41567433,0.5663786,0.42906415,-0.3496396,-0.8037924,-0.59630895,-0.27466714,0.5661104,1.8319073,0.42217153,-0.13905634,0.21579905,0.28269005,-0.5863708,-1.6216569,0.13251193,-0.37928987,-0.38373178,1.0773281,0.25534162,-0.40259826,-0.4632742,0.71163124,-0.5344507,-0.23922887,-0.601537,1.4480318,-0.20677155,-0.35658178,-1.1285872,0.26381725,-0.6875173,-0.03495778,0.8357181,0.13991642,-0.3198272,0.37847862,0.35239175,0.29512957,0.46219376,0.3489816,0.25090438,-0.18067755,-0.15464005,0.27996427,0.08491511,0.3674361,0.43549424,0.69384015,-0.32639167,0.39555025],"result":{"type":"object","properties":{"login_status":{"description":"The status of the email login","type":"string"},"mail_ids":{"description":"The list of generated unique mail IDs","items":{"type":"string"},"type":"array"},"skipped":{"description":"List of email IDs that were skipped","items":{"type":"string"},"type":"array"},"table_created":{"description":"Indicates if the email logging table was created","type":"boolean"}},"required":["table_created","mail_ids"]},"sql_tables":[{"name":"answered_emails","definition":"CREATE TABLE IF NOT EXISTS answered_emails (email_unique_id TEXT UNIQUE PRIMARY KEY, subject TEXT NOT NULL, email TEXT NOT NULL, response TEXT NOT NULL, received_date DATETIME NOT NULL, response_date DATETIME DEFAULT CURRENT_TIMESTAMP)"}],"sql_queries":[{"name":"Get answered emails","query":"SELECT * FROM answered_emails"},{"name":"Get email by unique ID","query":"SELECT * FROM answered_emails WHERE email_unique_id = :emailUniqueId"},{"name":"Insert new email","query":"INSERT INTO answered_emails (email_unique_id, subject, email, response, received_date) VALUES (:emailUniqueId, :subject, :email, :response, :receivedDate)"}],"file_inbox":null,"oauth":null,"assets":null,"runner":"any","operating_system":["linux","macos","windows"],"tool_set":""},false]}